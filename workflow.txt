LEGEND
    * Feature group fully implemented.
    + Feature fully implemented.
    - Feature or feature group not implemented.

WRECK WORKFLOW

* Initialize WRECK:
    + activate module import hook
    + initialize fake `compiler` module
* Parse command-line options:
    + fill WRECK.config object with values parsed from command line
* Check for any execution-aborting command line options (--help) and process them if necessary.
* Validate configuration:
    + ensure module_path is set and exists, terminate if not
    + check if module_info.py file exists, error if not
    + detect if we're dealing with Warband or M&B module
    + force black&white mode if on Windows and colorama library is not loaded
    + insert module_path as the first dir to check when importing modules
- Initialize compilation data:
    + define all data libraries
    + define syntax parsers for all checkable libraries
    - define processors and aggregators for all exportable libraries
    + if necessary, initialize opmasks for libraries where opmasks are optional
    + initialize shared module namespace
    + initialize all register references (regN, sN, posN)
    + register all 'protected' objects that WRECK will not allow module to change (registers, some functions etc)
* Preload header files:
    + attempt to preload all header files from module_path to fill shared namespace with data
- Initialize module settings:
    + load module_info.py file
    + if export_dir is defined in module_info.py and export_path hasn't been set from command line, use export_dir value
    + apply `write_id_files`, `show_performance_data` and `export_filename` config options from module_info.py
    + disallow plugins from executing properly, store them for later processing
    - allow override of most configuration settings from module_info.py file
        + maybe only do command line parsing AFTER module_info.py to ensure proper overrides
        + need to check for `module_path` before doing anything else
        - need to check for `help` before doing anything else
* Validate module settings:
    + check that export_path exists and is writeable
    + check if module.ini file is present at export_path, warn if it doesn't
    + load variables.txt file if it's available
- Run plugins in the same order as they were imported before:
    - check plugin dependencies if necessary, terminate compilation if dependencies do not match
    - allow plugins to export global variables (define them in shared namespace)
    - allow plugins to extend scripting syntax (create WreckCustomOperation objects in shared namespace)
    - collect plugin data extensions (`scripts`, `map_icons` etc) for later processing
    - collect plugin data injections (both old and new style) for later processing
    - if plugin has `preprocess_entities` function defined, store it for later processing
* Load all module files using shared namespace
- Apply delayed plugin effects:
    - extend all library sources with entries from plugins, honoring plugin load order
    - add starting and ending injection points for all data entries
    - add injection points in certain predefined data entries (like "script_game_start") for modder's convenience
- Validate module data:
    + parse data entries imported from modules, check syntax, bring data entries to standardized format
    + handle module-level injections during parsing
    - any syntax errors generated during parsing must correctly trace the origin of data entry (i.e. if it was present
      in the original module file, added by plugin or injected by plugin)
    + for as long as entry uid has been identified, syntax errors should not terminate compiler, instead error messages must be generated
    - messages about syntax errors must include highlighting of actual error with color (`path` variable is used)
* Resolve references:
    + finalize entry lists - from this moment no entries can be deleted, added or inserted
    + assign values to all game references according to their position in parsed library
    + from this moment all references with undefined values will resolve to 0 and generate error message
    + from this moment all expressions that use undefined operands will resolve to 0 silently (to prevent division by zero errors)
* Modify troop entries, applying upgrades defined with calls to upgrade(), upgrade2() and define_troop_upgrade().
- Run plugin preprocessors.
- Execute plugin data replacers.
- Compile all script objects:
    - handle script-level injections on the fly
    - replace syntax extensions with appropriate sequence of commands
    - resolve dynamic expressions, generating code on the fly
    - validate operations syntax
    - collect quick strings and global variables to appropriate libraries
- Compile module to bytecode:
    - for all libraries, run processor on all entries and aggregator to generate resulting bytecode
    - dialogs processor/aggregator are also responsible for filling dialog_states
- Export module if export hasn't been disabled and there were no errors during compilation:
    - export compiled module files (*.txt and a few others) to export_path.
    - generate and export resulting ID files (ID_*.py) to module_path.

COMPATIBILITY ISSUES:

- WreckAggregateValue should inherit from `int` instead of `dict`, and work seamlessly with int/bigint numeric values
  from vanilla compiler
    - aggregates must work seamlessly with numeric values from vanilla compiler
    - for aggregate types that may have modified offsets in header files, those offsets must be traced with import hook
- Injection points must be generated by compiler instead of requiring their presence in source files. This way, any
  module extension which parses through module entries won't stumble upon WRECK injection points as they won't exist
  at that point of time.
- For the same purpose, new injection syntax is required which does not rely on injection points at all.
- Is it possible to support code that collects information from module entries? Such code obviously resides AFTER
  data declaration, so if we could terminate code execution at that point, process all injections and then resume,
  it would be totally cool. So far this seems very unlikely.
- Extend list for our data libraries, so any modifications will automatically modify values of associated WreckVariable
  references, so they could be used as list indices immediately and transparently. This gets rid of evaluating refs!!!


POSSIBLE CRITICAL ERRORS DURING COMPILATION:

Init:
+ Missing module_path. No data to read.
+ Failed to auto-resolve an undefined variable in module code.
+ Unknown operation used in WreckVariable expression. Implies broken architecture somewhere.
+ Exhausted stack in current_module() handler. Implies broken architecture somewhere.
Syntax:
+ Failed to retrieve uid from data tuple. Cannot reliably fallback.
Compilation:
+ Attempt to retrieve property from dynamic variable. Implies broken code somewhere.
+ Attempt to evaluate property when sanitized data not available. Implies broken architecture somewhere.
+ General error in property evaluation. Implies broken code in property class.
+ Attempt to generate code from static variable/expression or reference. Implies broken architecture somewhere.

POSSIBLE ERRORS DURING COMPILATION:

Init:
+ File module_info.py was not found at module_path.
+ Setting export_path not defined, path does not exist or is not writeable or I/O check failed.
+ File variables.txt exists, but attempt to read resulted in I/O error.
Syntax:
+ Fatal syntax error in data tuple. Means uid was successfully generated. Fallback to some default value.
Compilation:
+ Undefined reference. Fallback to zero.
+ Attempt to calculate dynamic expression during compile time. Fallback to zero.
+ Failed to evaluate expression or generate code. Fallback to zero/empty list.
+ Attempt to create a reference when library is not extendable. Should succeed.
    Exception: if reference is never used, ignore.
+ Illegal call to define_troop_upgrade().

POSSIBLE MISTAKES DURING COMPILATION:

Init:
Syntax:
+ Data entry contains extra unparsed data. Possible error.
Compilation:

POSSIBLE WARNINGS DURING COMPILATION:

Init:
+ File module.ini not present at export_path.
Syntax:
+ Auto-resolve variable reference. Fired if WRECK had to handle NameError during module load.
    Except: if reference was not defined in ID file, used in code but is defined in ID file by end of compilation.
Compilation:

TODO:
+ modify all parsers to use fallback data instead of raising WreckParserException.
+ attempt to calculate dynamic expression at compile time should generate error instead of fail.
+ change config validators to use errors instead of exceptions for many situations.
+ get rid of WreckVariable.force_resolution, always fallback.
+ get rid of WreckVariable.is_required, use compile-time checks instead.
+ attempt to generate code from static expression should yield empty list and generate error, not fail.
+ error in expression calculation should yield zero/empty list and generate error, not fail.
+ attempt to create entry in non-extendable library should succeed and generate error, not fail.
+ failed call to define_troop_upgrade() should cause no effect and generate error, not fail.
+ missing/illegal/etc export path should generate error, not fail.
+ WRECK.resolve_references() should never fail.

SCRIPT PROCESSING WORKFLOW:

+ Scripts are not parsed during module syntax check. This would be redundant since we can't do script injection anyway
  at this point of time and so would have to parse those scripts with their injections for a second time later.
- Scripts are checked for syntax at the same time as they're compiled, so only a single pass is necessary to compile
  all game scripts. It is also the time when all script-level injections are resolved.
- All script operations must be tracked back to their origins:
    - Normal operations should point back to their module, script uid and operation number within the original script.
    - Injected operations should point to script uid, injection name, operation original plugin and operation number
      within that particular injection.
    - Injection points themselves can be defined in source code, plugin code or be dynamically placed by WRECK.
    - Some operations are generated by the injection point definition (prefixes, suffixes, separators and placeholders).
    - Dynamically generated operations point to original expression that was being resolved, possibly with the entire
      generated bytecode. That expression in turn is part of an operation which is referenced using the same data.
    - Operations can also be generated and/or modified by plugin preprocessor scripts. In this case it becomes possible
      to traceback their origins to the plugin filename and line where the change was initiated.
    - Operations can be generated by syntax extenders, called with specific set of parameters.

    (assign, reg0, 1), # operation #45 in script.game_start(#0) from module_scripts
    (assign, reg0, 2), # operation #45 in script.evalutate(#517) from plugin_test
    (assign, reg0, 3), # operation #11 in plugin_test.injections.game_start

    module_scripts -> script.game_start(#1) -> operation #45
    scripts -> module_scripts.game_start(#1) -> operation #45
    scripts -> plugin_test.evaluate(#517) -> operation #32
    scripts -> module_scripts.game_start(#1) -> injection('game_start') -> plugin_test.injections.game_start -> operation #3
    scripts -> module_scripts.game_start(#1) -> injection('game_start').prefix -> operation #1
    scripts -> module_scripts.game_start(#1) -> operation #54 -> expression((reg1 + reg2) / 2) -> operation #4
    scripts -> module_scripts.game_start(#1) -> operation #61 -> plugin_my_syntax.store_average(reg0, 1, 2, 3, 4) -> operation #6

Error when compiling code object mnu.visit_lady(#433).mno_antechamber(#1).conditions:
  mnu.visit_lady(#433).mno_antechamber(#1).conditions
    op #14: inject.charming_lady
      injection #1: plugin_poetry.injection.charming_lady
        op #2: (store_max_from_list, reg0, reg1, reg2, reg3 + l.bonus, reg4),
          plugin_maths.store_max_from_list(reg0, reg1, reg2, reg3 + l.bonus, reg4)
            op #1: (val_max, reg0, reg3 + l.bonus),
              dynamically generated code for expression: reg3 + l.bonus
                operand #2: l.bonus
                  local variable ":bonus" (l.bonus) may be undefined: it is defined in some conditional branches before this point, but not all of them
